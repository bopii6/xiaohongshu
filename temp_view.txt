// è…¾è®¯äº‘æ··å…ƒå¤§æ¨¡å‹å®¢æˆ·ç«?import crypto from 'crypto';
import { HunyuanConfig, HunyuanModel, HUNYUAN_MODELS } from './config';

// APIè¯·æ±‚å‚æ•°æ¥å£
export interface HunyuanChatParams extends Record<string, unknown> {
  Model: string;
  Messages: Array<{
    Role: 'user' | 'assistant';
    Content: string;
  }>;
  Temperature?: number; // 0.0-1.0ï¼Œæ§åˆ¶éšæœºæ€?  TopP?: number; // 0.0-1.0ï¼Œæ§åˆ¶æ ¸é‡‡æ ·
  Stream?: boolean; // æ˜¯å¦æµå¼è¾“å‡º
  Seed?: number; // éšæœºç§å­
}

// APIå“åº”æ¥å£
export interface HunyuanResponse {
  RequestId: string;
  Note: string;
  Usage: {
    PromptTokens: number;
    CompletionTokens: number;
    TotalTokens: number;
  };
  Choices: Array<{
    FinishReason: string;
    Message: {
      Role: string;
      Content: string;
    };
  }>;
  Created: number;
  Id: string;
}

// é”™è¯¯å“åº”æ¥å£
export interface HunyuanErrorResponse {
  Error: {
    Code: string;
    Message: string;
  };
  RequestId: string;
}

export class HunyuanClient {
  private config: HunyuanConfig;

  constructor(config: HunyuanConfig) {
    this.config = {
      region: 'ap-guangzhou',
      timeout: 60000,
      maxRetries: 3,
      ...config
    };

    console.log('[HunyuanClient] åˆå§‹åŒ–é…ç½?, {
      secretIdPrefix: this.config.secretId?.slice(0, 6),
      region: this.config.region,
      defaultModel: this.config.defaultModel,
      timeout: this.config.timeout,
      maxRetries: this.config.maxRetries
    });
  }

  /**
   * ç”Ÿæˆè…¾è®¯äº‘APIç­¾å
   */
  private generateSignature(
    method: string,
    endpoint: string,
    params: Record<string, unknown>,
    timestamp: number,
    headers: Record<string, string>
  ): string {
    const httpRequestMethod = method;
    const canonicalUri = '/';
    const canonicalQueryString = '';
    const canonicalHeaders = Object.entries(headers)
      .sort(([a], [b]) => a.toLowerCase().localeCompare(b.toLowerCase()))
      .map(([key, value]) => `${key.toLowerCase()}:${value}`)
      .join('\n') + '\n';

    const signedHeaders = Object.keys(headers)
      .sort()
      .map(key => key.toLowerCase())
      .join(';');

    const payload = JSON.stringify(params);
    const hashedPayload = crypto.createHash('sha256').update(payload).digest('hex');

    const canonicalRequest = `${httpRequestMethod}\n${canonicalUri}\n${canonicalQueryString}\n${canonicalHeaders}\n${signedHeaders}\n${hashedPayload}`;

    const date = new Date(timestamp * 1000).toISOString().slice(0, 10);
    const service = 'hunyuan';
    const credentialScope = `${date}/${service}/tc3_request`;
    const stringToSign = `TC3-HMAC-SHA256\n${timestamp}\n${credentialScope}\n${crypto.createHash('sha256').update(canonicalRequest).digest('hex')}`;

    const secretDate = crypto.createHmac('sha256', `TC3${this.config.secretKey}`).update(date).digest();
    const secretService = crypto.createHmac('sha256', secretDate).update(service).digest();
    const secretSigning = crypto.createHmac('sha256', secretService).update('tc3_request').digest();

    const signature = crypto.createHmac('sha256', secretSigning).update(stringToSign).digest('hex');

    console.log('[HunyuanClient] ç”Ÿæˆç­¾å', {
      credentialScope,
      signedHeaders,
      payloadHash: hashedPayload,
      timestamp
    });

    return `TC3-HMAC-SHA256 Credential=${this.config.secretId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
  }

  /**
   * å‘èµ·APIè¯·æ±‚
   */
  private async makeRequest(
    params: HunyuanChatParams,
    retryCount = 0
  ): Promise<HunyuanResponse> {
    const endpoint = 'hunyuan.tencentcloudapi.com';
    const timestamp = Math.floor(Date.now() / 1000);

    const baseHeaders = {
      'Content-Type': 'application/json; charset=utf-8',
      'Host': endpoint,
      'X-TC-Action': 'ChatCompletions',
      'X-TC-Timestamp': timestamp.toString(),
      'X-TC-Version': '2023-09-01',
      'X-TC-Region': this.config.region!
    };

    const authorization = this.generateSignature('POST', endpoint, params, timestamp, baseHeaders);
    const headers = {
      ...baseHeaders,
      'Authorization': authorization
    };

    console.log('[HunyuanClient] è¯·æ±‚å¤´ä¿¡æ?, {
      action: baseHeaders['X-TC-Action'],
      region: baseHeaders['X-TC-Region'],
      timestamp: baseHeaders['X-TC-Timestamp'],
      signedHeaders: Object.keys(baseHeaders).map(key => key.toLowerCase()).join(';')
    });

    try {
      const response = await fetch(`https://${endpoint}`, {
        method: 'POST',
        headers,
        body: JSON.stringify(params),
        signal: AbortSignal.timeout(this.config.timeout!)
      });

      const data = await response.json();

      if (!response.ok || data?.Response?.Error) {
        const errorInfo = data?.Response?.Error;
        throw new Error(
          errorInfo
            ? `è…¾è®¯äº‘APIé”™è¯¯: ${errorInfo.Code} - ${errorInfo.Message}`
            : 'è…¾è®¯äº‘APIå“åº”å¼‚å¸¸'
        );
      }

      return data.Response as HunyuanResponse;
    } catch (error: unknown) {
      if (
        error instanceof Error &&
        error.name === 'TimeoutError' &&
        retryCount < this.config.maxRetries!
      ) {
        const delay = Math.pow(2, retryCount) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.makeRequest(params, retryCount + 1);
      }

      if (
        error instanceof Error &&
        error.message?.includes('RateLimit') &&
        retryCount < this.config.maxRetries!
      ) {
        const delay = Math.pow(2, retryCount) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.makeRequest(params, retryCount + 1);
      }

      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`è…¾è®¯äº‘æ··å…ƒè¯·æ±‚å¤±è´? ${error}`);
    }
  }

  /**
   * èŠå¤©å¯¹è¯
   */
  async chat(
    model: HunyuanModel,
    params: Omit<HunyuanChatParams, 'Model'> & { Messages: HunyuanChatParams['Messages'] }
  ): Promise<HunyuanResponse> {
    try {
      const requestParams: HunyuanChatParams = {
        Model: model,
        ...params
      };
      const response = await this.makeRequest(requestParams);

      return response;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`è…¾è®¯äº‘æ··å…ƒAPIè°ƒç”¨å¤±è´¥: ${error}`);
    }
  }

  /**
   * æµå¼èŠå¤©
   */
  async *chatStream(
    model: HunyuanModel,
    params: Omit<HunyuanChatParams, 'Model'>
  ): AsyncGenerator<string, void, unknown> {
    const streamParams = { ...params, Stream: true };

    try {
      const endpoint = 'hunyuan.tencentcloudapi.com';
      const timestamp = Math.floor(Date.now() / 1000);

      const baseHeaders = {
        'Content-Type': 'application/json; charset=utf-8',
        'Host': endpoint,
        'X-TC-Action': 'ChatCompletions',
        'X-TC-Timestamp': timestamp.toString(),
        'X-TC-Version': '2023-09-01',
        'X-TC-Region': this.config.region!
      };

      const authorization = this.generateSignature('POST', endpoint, {Model: model, ...streamParams}, timestamp, baseHeaders);
      const headers = {
        ...baseHeaders,
        'Authorization': authorization
      };

      const response = await fetch(`https://${endpoint}`, {
        method: 'POST',
        headers,
        body: JSON.stringify({Model: model, ...streamParams}),
        signal: AbortSignal.timeout(this.config.timeout!)
      });

      if (!response.ok) {
        const errorData: HunyuanErrorResponse = await response.json();
        throw new Error(`è…¾è®¯äº‘APIé”™è¯¯: ${errorData.Error.Code} - ${errorData.Error.Message}`);
      }

      if (!response.body) {
        throw new Error('å“åº”ä½“ä¸ºç©?);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();

        if (done) break;

        const chunk = decoder.decode(value);
        // è…¾è®¯äº‘æµå¼å“åº”æ ¼å¼å¤„ç?        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const dataStr = line.slice(6);
            if (dataStr === '[DONE]') {
              return;
            }

            try {
              const data = JSON.parse(dataStr);
              if (data.Choices && data.Choices[0]?.Delta?.Content) {
                yield data.Choices[0].Delta.Content;
              }
            } catch (parseError) {
              console.warn('è§£ææµå¼å“åº”å¤±è´¥:', parseError);
            }
          }
        }
      }
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`è…¾è®¯äº‘æ··å…ƒæµå¼è°ƒç”¨å¤±è´? ${error}`);
    }
  }

  /**
   * è®¡ç®—tokenè´¹ç”¨
   */
  calculateCost(model: HunyuanModel, inputTokens: number, outputTokens: number): number {
    const config = HUNYUAN_MODELS[model];
    const totalTokens = (inputTokens + outputTokens) / 1000; // è½¬æ¢ä¸ºåƒtokens
    return totalTokens * config.price;
  }

  /**
   * ç”Ÿæˆè¯·æ±‚IDï¼ˆç”¨äºè¿½è¸ªï¼‰
   */
  generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
